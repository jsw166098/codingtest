# 계수 정렬

> 데이터의 크기 범위가 정수 형태로 제한되어 표현할 수 있을 때 사용할 수 있는 알고리즘

## 제한 특징
~~~
1. 정수 형태를 가지고 있어야 한다.
2. 최댓값과 최솟값 차이가 크지 않아야 한다.
~~~

## 특징
* 데이터 개수가 N, 최댓값이 K일 때 최악의 경우에도 O(N+K)를 보장한다.
* 매우 빠르게 동작하며 원리 또한 간단하다.
* 데이터의 범위, 크기가 제한되어 있을 때 데이터의 개수에 상관없이 빠르게 동작한다. 
* 무한한 범위를 가진 실수 형태의 데이터의 경우 적용하기 어렵다.
* 가장 큰 데이터와 작은 데이터 차이가 1,000,000을 넘지 않을 때 보통 효과적으로 사용할 수 있다. 

### 모든 범위를 담을 수 있는 크기의 리스트를 선언해야 한다.
* 최대값과 최소값 차이만 큼에서 1을 더한 크기를 가진 리스트를 선언해야 한다.
* 따라서 최대 최소 차이가 커지면 선언해야 하는 크기 역시 커지기 때문에 계수 정렬을 사용하기 어렵다. 

## 비교 기반 정렬 알고리즘
> 데이터를 직접 비교하며 위치를 변경하는 정렬 방법
* 데이터를 직접 비교한다.
* 위치를 직접 변경한다.
* 선택 정렬, 삽입 정렬, 퀵 정렬 등이 존재한다.

계수 정렬은 비교 기반 정렬 알고리즘이 아니다. `별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다.` 즉 직접 데이터를 비교하고 변경하는 작업을 실시하지 않는다.

---

## 알고리즘

1. 가장 큰 데이터와 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 선언한 후 0으로 값을 초기화 한다. -> `최댓값 - 최솟값 + 1` 만큼의 데이터를 담을 수 있도록 선언한다.
2. 데이터에 하나씩 접근하며 해당 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다. -> 각 데이터가 몇 번 등장했는지 그 횟수가 기록된다. 

~~~
# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7,5,9,0,3,1,6,2,9,1,4,8,0,5,2]

# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0]*(max(array)+1)

for i in range(len(array)):
    count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가 

for i in range(len(count)):  # 리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        print(i, end=' ')  # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력
~~~


