# 정렬

> 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다. 

## 선택 정렬

> 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복한다.
* 가장 작은 데이터를 앞으로 보내는 과정을 N-1번 반복한다.
* 시간 복잡도는 $O(n^2)$ 이다. 
~~~
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):  // 1. 원소 길이 만큼 반복문
    min_index = i  // 2. 이동하면서 최소값 인덱스 받을 변수 

    for j in range(i+1, len(array)):  //3. i 이후의 인덱스 접근 
        if array[min_index] > array[j]:  //4. 역전 상황에 대한 조건문
            min_index = j
    
    array[min_index], array[i] = array[i], array[min_index]  //5. 스왑!!
        
~~~

* 인덱스 접근 -> i, j, min_index
~~~
i : 모든 원소에 접근하며 정렬된 그룹과 정렬되지 않은 그룹을 나누게 된다.
j : i 이후의 원소에 접근하며 정렬되지 않은 그룹 모든 원소에 접근한다.
min_index : 최소값 원소의 인덱스를 가지며 조건문을 거친후 전달 받게 된다. 
~~~

선택 정렬, 삽입 정렬 모두 정렬된 그룹과 정렬되지 않은 그룹이 나뉘어져 있다고 볼 수 있다. 하지만 차이점은 정렬된 그룹의 인덱스에 해당된다. 선택 정렬의 경우 본래의 인덱스가 고정된 상태에서 마지막에 원소가 삽입되다. 삽입 정렬의 경우 해당 그룹에서 적절한 인덱스에 삽입되기 때문에 그룹 내의 본래 인덱스가 바뀔 수 있다. 
---


## 삽입 정렬

> 정렬된 리스트의 적절한 위치에 데이터를 삽입하는 방법이다.

* 선택 정렬 보다 실행 시간 측면에서 효율적이며 선택 정렬 처럼 모든 원소를 비교하고 위치를 바꾸지 않는다. 
* 필요할 때만 위치를 바꾸게 되며 이미 정렬된 경우 효율적인 성능을 보인다.
* 두 번째 데이터부터 시작한다. -> 첫 번째 데이터는 그자체로 정렬되어 있다고 판단!
* 특정한 데이터의 왼쪽에 위치한 데이터는 이미 정렬된 상태이므로 자기보다 작은 데이터를 만났다면 더 이상 데이터를 살펴볼 필요 없이 그 자리에 삽입되면 된다. 
* 시간 복자도: $O(n^2)$, 최선의 경우(거의 정렬된 상태)는 $O(n)$ 으로 퀵 정렬보다 성능이 좋다고 할 수 있다.

~~~
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array))  // 1. 두번째 원소부터 적근, 정렬된 경우와 정렬되지 않은 경우로 그루핑
    for j in range(i, 0, -1)  // 2. i를 포함에서 1까지 집근, 정렬 된 경우의 그룹을 접근
        if array[j] < array[j-1]  // 3. 앞의 원소보다 작으면 이동시킨다.
            array[j], array[j-1] = array[j-1], array[j]
        else:   // 4. 앞의 원소보다 크면 중지 시킨다. 
            break
~~~

* 인덱스 접근 -> i, j
~~~
i : 두번째 원소부터 적근, 정렬된 경우와 정렬되지 않은 경우로 그루핑
j: i를 포함에서 1까지 집근, 정렬 된 경우의 그룹을 접근 
~~~

---

## 퀵 정렬

> 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.

* 가장 많이 사용되고 병합 정렬과 함께 정렬 라이브러리의 근간이 된다. 
* 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작

### 피벗(Pivot)

> 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '가준'이다.

* `피벗을 설정하고 리스트를 분할` 하는 방법에 따라서 여러 가지 방식으로 퀵 정렬 구분
* 리스트에서 첫 번째 데이터를 피벗으로 정하는 `호어 분할(Hoare Partition)` 방식 사용
* 결과적으로 피벗을 기준으로 왼쪽에는 피벗보다 작은 데이터, 오른쪽에는 피벗보다 큰 데이터가 위치한다. 

### 분할(Divde), 파티션(Partiotion)
> 피벗을 기준으로 왼쪽에는 피벗보다 작은 데이터, 오른쪽에는 피벗보다 큰 데이터가 위치하는 작업을 의미한다. 

### 구현

* 피벗을 설정한 뒤에는 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다. 그다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다. 
* 파트1: 리스트 첫 번째 요소를 피벗으로 설정 후 왼쪽에서 부터 피벗보다 큰 원소를 오른쪽에서는 피벗보자 작은 원소를 찾아 교환한다. 만약 엇갈리게 되면 작은 요소를 피벗과 교환한다.
* 파트2: 왼쪽 리스트에 대해서 퀵 정렬을 실시한다.
* 파트3: 오른쪽 리스트에 대해서 퀵 정렬을 실시한다. 
* 각 파트들은 재귀로 구현하며 종료 조건은 원소개수가 1개일 때로 설정한다. 

~~~
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    if start >= end:  # 원소가 1개인 경우 <종료조건>
        return
    
    pivot = start  # 피벗을 첫 번째 원소 <인덱스 설정(피벗, left, right)>
    left = start + 1
    right = end

    while left <= right:
        
        # 피벗보다 큰 데이터를 찾을 때까지 반복 <left 인덱스 이동>
        while left <= end and array[left] <= array[pivot]:
            left += 1
        
        # 피벗보다 작은 데이터를 찾을 때까지 반복  <right 인덱스 이동>
        while right > start and array[right] >= array[pivot]:
            right -= 1
        
        # 엇 갈렸다면 작은 데이터와 피벗을 교체 
        if left >right:
            array[right], array[pivot] = array[pivot], array[right]
        else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
            array[left], array[right] = array[right], array[left]
        
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right-1)
    quick_sort(array, right+1, end)

quick_sort(array, 0, len(array)-1)
print(array)
~~~

