# DFS, BFS

## 탐색

> 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정

그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다. 

---
## 그래프의 기본 구조

* 노드(Node), 정점(Vertex)과 간선으로 구성된다.
* 두 노드가 간선으로 연결되어 있다면 두 노드는 인접하다고 한다. 

### 그래프 표현 방식

* 인접 행렬(Adjacency Matrix) 
* 인접 리스트(Adjacency List) 

### 인접 행렬
* 2차원 배열로 그래프의 연결 관계를 표현하는 방식
* 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식
* 2차원 리스트로 구현

~~~
INF = 999999999

graph = [
    [0,7,5],
    [7,0,INF],
    [5,INF,0]
]

print(graph)  ## [[0,7,5], [7,0,999999999], [5, 999999999, 0]]
~~~

### 인접 리스트
* 리스트로 그래프의 연결 관계를 표현하는 방식 
* 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장

~~~
graph = [[] for _ in range(3)]

# (노드값, 간선값)
graph[0].append((1, 7))
graph[0].append((2, 5))

graph[1].append((0, 7))

graph[2].append((0, 5))

print(graph)  ## [[(1,7), (2,5)], [(0,7)], [(0, 5)]]
~~~

### 인접 행렬, 리스트 방식 차이

* 메모리 측면에서 인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비된다. 반면 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다. 

* 속도 측면에서 인접 리스트 방식은 인접 행렬 방식에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다. 연결된 데이터를 하나씩 확인해야 하기 때문이다. 

---

## DFS(Dpth-First Search)

> 깊이 우선 탐색이라고 부르며 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다. 

특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한후, 다시 돌아가 다른 경로로 탐색하는 알고리즘이다.

### DFS 스택 자료구조

~~~
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다. 
~~~

~~~
def dfs(graph, v, visited):
    visited[v] = True
    print(v, end=' ')

    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

graph = [
    [],
    [2,3,8],
    [1,7], 
    [1,4,5], 
    [3, 5],
    [3, 4], 
    [7],
    [2,6,8],
    
    [1, 7]
] 

visited = [Faluse]*9
dfs(graph, 1, visited)
~~~

---

## BFS(Breadth First Search)

> 너비 우선 탐색이라는 의미를 가지며 가까운 노드부터 탐색하는 알고리즘이다.

DFS는 최대한 멀리 있는 노드를 우선으로 탐색하는 반면 BFS는 가까운 노드부터 탐색하게 된다. 

### BFS 큐 자료구조

~~~
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때 까지 반복한다. 
~~~

~~~
from collectons import deque

def bfs(graph, start, visited):
    queue = deque([start])
    visited[start] = True

    while queue:
        v = queue.popleft()
        print(v, end=" ")

        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

graph = [
    [],
    [2,3,8],
    [1,7], 
    [1,4,5], 
    [3, 5],
    [3, 4], 
    [7],
    [2,6,8],
    [1, 7]
]

visited = [False]*9
bfs(graph, 1, visited)
~~~
---

## DFS, BFS

* 1차원 배열, 2차원 배열 같은 경우 그래프 형태로 생각하여 문제를 풀어낸다. 
* 각 좌표를 상하좌우로 이동할 수 있는 경우

||DFS|BFS|
|---|---|---|
|동작원리|스택|큐|
|구현방법|재귀함수 이용|큐 자료구조 이용|

