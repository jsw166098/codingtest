# 다이나믹 프로그래밍 

* 다이나믹 프로그래밍(Dynamic programming) 또는 동적 계획법이라고도 불린다.
* 연산 속도와 메모리 공간을 최대한 활용하는 효율적인 알고리즘
* 메모리 공간을 약간 더 사용하여 연산 속도를 비약적으로 증가시킨다. 

## 다이나믹
> 다이나믹은 프로그램이 실행도중에 라는 의미를 가지고 있다.
* 동적 할당(Dynamic Allocation)은 프로그램 실행 중에 프로그램 실행에 필요한 메모리를 할당하는 기법이다.
* 다이나픽 프로그램에서 다이나믹은 이 의미와 다르다.

## 피보나치 수열

* 현재 항이 이전 두 항의 합으로 설정되는 수열

### 수열
* 수열은 여러 개의 수가 규칙에 따라서 배열된 형태를 의미한다.
* 배열과 리스트로 표현할 수 있으며 파이썬의 경우 리스트, C/C++ 등에서는 배열을 이용한다. 


### 점화식
* 인접한 항들 사이의 관계식
* 수학적 점화식을 프로그래밍으로 표현하면 **재귀 함수**를 보통 사용하게 된며 **반복문**을 통해서도 물론 구현된다. -> 탑다운, 보텀업 방식으로 모두 구현
* 피보나치 수열의 점화식은 인접 3항간 점화식이다. 
~~~
a_(n+2) = f(a_(n+1), a_n) = a_(n+1) + a_n
a_n = a_(n-1) + a_(n_2), a_1 = 1, a_2 = 1 
~~~

#### 점화식을 통한 재귀 함수로 구현된 피보나치 수열

* 시간 복잡도가 O(2^N)이다.
* n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어난다. 
* 이미 계산한 결과가 계속 호출된다. n이 커지면 커질수록 반복 호출이 늘어난다. 
~~~
# 수학적 점화식을 바탕으로 재귀 함수로 구현된 피보나치 수열
def fibo(x):
    if x==1 or x==2:
        return 1
    return fibo(n-1) + fibo(n-2)
print(fibo(4))
~~~

---

## 다이나믹 프로그래밍(Dynamic programming), 동적 계획법

### 동적 계획법 조건
1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

### 탑다운 방식
* 다이나믹 프로그래밍 기법을 메모이제이션 기법을 통해 구현 
* 다이나믹 프로그래밍을 재귀적으로 함수를 호출하는 기법을 의미한다. 
* 한 번 구한 정보를 리스트에 저장하는 방법으로 구현된다. 재귀적으로 수행되다가 같은 정보가 필요할 때 이미 구한 정답을 그대로 리스트에서 가져온다. 

#### 메모이제이션(Memoization)
> 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법이다.
* 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미 
* 다이나믹 프로그래밍을 구현하는 방법 중 하나이며 탑다운에 국한된 개념이다. 또한 DP와 별도의 개념이다.
* 캐싱(Cashing)은 메모이제이션 값을 저장하는 방법이다.

~~~
# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0]*100

# 피보나치 함수(Fibonacci Function)를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
def fibo(x):
    # 1. 종료 조건(1 혹은 2일 때 1을 반환)
    if x==1 or x==2:
        return 1
    # 2. 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]

    # 3. 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x-1) + fibo(x-2)
    
    return d[x]

print(fibo(99))
~~~

### 보텀업 방식
* 하향식이라고도 하며 다이나믹 프로그래밍의 전형적인 형태이다.
* 보텀업 방식에서 사용되는 결과 저장용 리스트는 `DP 테이블`이다.
~~~
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0]*100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 2
n = 99

# 피보나치 함수(Fibonacci Function) 반복문으로 구현(보텀업 다이나믹 프로그래밍)
for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]

print(d[n])
~~~

---

## 문제 분석

* 적용 형식! 보텀업, 탑다운 모두 적용된다. 
~~~
1. DP 테이블 생성
2. 초기 조건 구성
3. 그 다음 조건 구성 -> 점화식 적용
~~~

* 적용 방법
~~~
1. 동적 계획법 적용 가능한지 확인 (i 번째 작업 기준으로 상황 분류 가능?)
2. 점화식 세워 코드 작성한다.
3. 적용 형식 사용!
~~~
* 동적 계획법 적용 확인 어려운 경우는 초기 조건부터 조건에 맞는 작업을 실시하며 진행하는 것으로 생각!!
* 다음 조건을 통해 코드를 작성하거나 문제를 하나씩 분석할 때 이전의 작업들은 신경쓰지 않아도 된다. 
* 초기조건 -> 점화식 -> 중복제거 !!